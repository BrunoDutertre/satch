/*------------------------------------------------------------------------*/
//   Copyright (c) 2021, Armin Biere, Johannes Kepler University Linz     //
/*------------------------------------------------------------------------*/

// This is the library code for the SAT solver Satch with API in 'satch.h'
// except for 'satch_{compile,identifier,version}' which are defined in
// 'config.c' automatically generated by 'mkconfig.sh'.  If you do not need
// those, then you can directly link against 'satch.o' unless you want the
// online internal proof checking code included from 'catch.[ch]', which
// requires to keep 'NDEBUG' undefined.  Not defining 'NDEBUG' also enables
// assertion checking, of course, but also witness checking and includes
// logging code. The latter still needs to be enabled at run-time through
// 'satch_enable_logging_messages' then.

// So again, if you do not want to use our build set-up (including
// './configure.sh') but just want to compile against this file instead of
// linking against the library and do not need proof checking in 'catch.c'
// (because you are not working on the 'satch' library itself) then just
// define 'NDEBUG' by for instance using '-DNDEBUG' as compiler option to
// compile this file, which then can be directly linked to your application.

/*------------------------------------------------------------------------*/

#include "satch.h"		// API of the solver.

/*------------------------------------------------------------------------*/

#include <assert.h>
#include <math.h>
#include <inttypes.h>
#include <limits.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*------------------------------------------------------------------------*/

// System specific include files for 'getrusage', 'stat', and 'access'.

#include <sys/resource.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

/*------------------------------------------------------------------------*/

// The library has the following configuration parameters in form of compile
// time macros, which disable or enable certain features through arguments
// to './configure.sh'.  As with the common 'NDEBUG' macro we use negated
// semantics, i.e., defining the macro disables the feature (since for
// instance the 'N' in 'NDEBUG' means [N]o debugging - see 'man assert').
//
//   NDEBUG    disable proof, witness and assertion checking
//
//   NBLOCK    disable blocking literals (thus slower propagation)
//   NFLEX     disable embedding of literals as flexible array into clause
//   NLEARN    disable keeping learned clauses (DPLL with backjumping)
//   NMINIMIZE disable clause minimization during learning
//   NREDUCE   disable clause reduction completely (keep all clauses)
//   NRESTART  disable restarts completely (moving average based)
//   NSORT     disable sorting of bumped literals in focused mode
//   NSTABLE   disable switching between stable and focused mode
//   
// While 'NDEBUG' is used frequently through-out the code the other macros
// are only used to disable specific default features in order to run and
// profile the code without a certain feature (for didactic reasons).

/*------------------------------------------------------------------------*/

// The following checks are in essence documentation. The 'configure.sh'
// script would on purpose leave out the implied macro (and raise an error
// message if both are used).

// NLEARN implies NREDUCE
//
#if defined(NLEARN) && !defined(NREDUCE)
#define NREDUCE
#endif

// NLEARN implies NMINMIZE
//
#if defined(NLEARN) && !defined(NMINIMIZE)
#define NMINIMIZE
#endif

// NRESTART implies NSTABLE
//
#if defined(NRESTART) && !defined(NSTABLE)
#define NSTABLE
#endif

/*------------------------------------------------------------------------*/

// Hard coded options for simplicity.

#define slow_alpha		1e-5	// exponential moving average decay

#ifndef NRESTART
#define fast_alpha		3e-2	// exponential moving average decay
#define restart_interval	1	// basic (focused) restart interval
#define restart_margin		1.25	// margin for fast_glue > slow_glue
#ifndef NSTABLE
#define mode_interval		1e3	// mode switching conflict interval
#define stable_restart_interval	1024	// basic stable restart interval
#endif
#endif

#ifndef NREDUCE
#define reduce_fraction         0.75	// reduced number of clauses
#define reduce_glue_limit	2	// kept glue limit
#define reduce_interval  	300	// base reduce conflicts interval
#endif

#ifndef NMINIMIZE
#define minimize_depth		1e4	// recursive minimization depth
#endif

/*------------------------------------------------------------------------*/

// Local include files.

#ifndef NDEBUG
#include "catch.h"		// Online proof checker for testing.
#endif

#include "stack.h"		// Generic stack implementation.

/*------------------------------------------------------------------------*/

// We use 'unsigned (int)' as type for internal literals and variable
// indices.  Our internal variable indices start at zero and literals are
// variable indices multiplied by two. The lowest bit of a literal denotes
// its sign.  The following function maps variables indices to literals.

static inline unsigned
LITERAL (unsigned idx)
{
  assert (idx < (1u << 31));	// check for no overflow
  return idx << 1;
}

// Vice versa this function maps literals to their variable index.

static inline unsigned
INDEX (unsigned lit)
{
  return lit >> 1;
}

// The least significant bit of a literal is its sign.

static inline unsigned
SIGN (unsigned lit)
{
  return lit & 1;
}

// Negating a literal amounts to flipping its least significant bit.

static inline unsigned
NOT (unsigned lit)
{
  return lit ^ 1;
}

// Note that the API uses signed integers for literals.  These signed
// external DIMACS variable indices are in the range '1..INT_MAX' and are
// mapped to internal variable indices '0..(INT_MAX-1)'.  Regarding literals
// the mapping between internal and external literals is the following:
//
// +----------------------------------------+----------------------------+
// | external signed DIMACS literals        | internal unsigned literals |
// +----------------------------------------+----------------------------+
// |     1                                  |    0                       |
// |    -1                                  |    1                       |
// |     2                                  |    2                       |
// |    -2                                  |    3                       |
// |    ...                                 |   ...                      |
// |  INT_MAX =   (1u<<31)-1  =  2147483647 | (1u<<32)-4 = 4294967292    |
// | -INT_MAX = -((1u<<31)-1) = -2147483647 | (1u<<32)-3 = 4294967293    |
// +----------------------------------------+----------------------------+
//
// We use the following two invalid values as sentinel to terminate a
// clause externally or as invalid literal or variable internally:
//
// +----------------------------------------+----------------------------+
// |     0                                  | INVALID    = (1u<<32)-1    |
// |                                        |            = 4294967295    |
// |                                        |            = UINT_MAX      |
// +----------------------------------------+----------------------------+
//
// There are two unused values in each case:
//
// +----------------------------------------+----------------------------+
// | INT_MIN = -(1u<<31)      = -2147483648 | (1u<<32)-2 = 4294967294    |
// +----------------------------------------+----------------------------+
//
// Here we assume that 'sizeof (unsigned) == sizeof (int)', signed integers
// are encoded in two-complement and thus 'INT_MAX == (1u<<31)-1'.
//
// It would be possible to also use 'int' for literals internally, but then
// iterator code would become much more complicated.  Access to positively
// and negatively indexed arrays, i.e., watches and values, would be strange
// and requires complex reallocation code too (for incremental usage).
//
// Thus we allow up to 'INT_MAX' variables and use the following all-bits-one
// number to denote invalid literals and variable indices '(1u<<32)-1'.

#define INVALID UINT_MAX

/*------------------------------------------------------------------------*/

struct clause
{
  uint64_t id;			// from 'solver->statistics.added'
  bool garbage;			// collect clause at next garbage collection
  bool protected;		// do not collect reason clauses
  bool redundant;		// redundant / learned (not irredundant)
  bool used;			// used since last clause reduction
  unsigned glue;		// glucose level (LBD)
  unsigned size;		// size of clause (number of literals)
#ifndef NFLEX
  // This default version embeds the literals directly into the clause.
  // Then the literals follows the clause header directly in memory
  // and thus makes the actual allocated bytes of a clause variadic.
  // This language concept is called 'flexible array members' in C.
  //
  unsigned literals[];
#else
  // This version stores the literals separately which requires another
  // pointer dereference accessing the literal. 
  //
  unsigned *literals;
#endif
};

struct link			// Links for decision queue.
{
  unsigned prev;
  unsigned next;
  unsigned stamp;
};

struct clauses			// Stack of clause pointers.
{
  struct clause **begin, **end, **allocated;
};

struct watch
{
#ifndef NBLOCK			// Unless defined use blocking literals.
  unsigned size;		// Cached 'clause->size' in watch and
  unsigned blocking;		// one blocking literal of the clause.
#endif
  struct clause *clause;	// The actual clause.
};

struct watches			// Stack of watches.
{
  struct watch *begin, *end, *allocated;
};

struct limits
{
#ifndef NRESTART
  uint64_t restart;		// Conflict limit on restarting.
#ifndef NSTABLE
  struct
  {
    uint64_t conflicts;		// Conflict limit on mode switching.
    uint64_t ticks;		// Ticks limit on mode switching.
  } mode;
#endif
#endif
#ifndef NREDUCE
  struct
  {
    uint64_t conflicts;		// Conflict limit on reducing.
    unsigned fixed;		// Root level fixed at reduction.
  } reduce;
#endif
};

#ifndef NSTABLE
struct reluctant		// Reluctant doubling (by D. Knuth).
{
  uint64_t u, v;
};
#endif

struct options			// Runtime options.
{
#ifndef NDEBUG
  bool logging;
#endif
  unsigned verbose;
};

struct statistics		// Runtime statistics.
{
  uint64_t conflicts;		// Total number of conflicts.
  uint64_t decisions;		// Total number of decisions.
  uint64_t propagations;	// Propagated literals.
#ifndef NREDUCE
  uint64_t reductions;		// Number of reductions.
#endif
#ifndef NRESTART
  uint64_t restarts;		// Number of restarts.
#ifndef NSTABLE
  uint64_t switched;		// Number of mode switches.
#endif
#endif
  uint64_t ticks;		// Propagation ticks.

  uint64_t added;		// Number of added clauses.
  uint64_t deleted;		// Number of deleted clauses.
  uint64_t irredundant;		// Current number of irredundant clauses.
  uint64_t redundant;		// Current number of redundant clauses.

  uint64_t deduced;		// Deduced literals.
  uint64_t learned;		// Learned literals.
#ifndef NMINIMIZE
  uint64_t minimized;		// Minimized literals.
#endif

  uint64_t sections;		// Number of calls to 'section'.
  uint64_t reported;		// Number of calls to 'report'.

  unsigned active;		// Remaining variables.
  unsigned eliminated;		// Eliminated variables.
  unsigned fixed;		// Root level assigned variables (units).
};

struct queue			// variable move to front decision queue
{
  unsigned first;		// first (enqueued) variable index
  unsigned last;		// last (enqueued) variable index
  unsigned search;		// cache search in 'decide'
  unsigned stamp;		// enqueue time stamp
};

struct analyzed			// Analyzed / seen variables.
{
  unsigned idx;
#ifndef NSORT
  unsigned stamp;		// Needed for sorting bumped variables only.
#endif
};

struct analyzed_stack		// Stack of analyzed indices with stamps.
{
  struct analyzed *begin, *end, *allocated;
};

struct trail			// Pre-allocated stack of literals.
{
  unsigned *begin, *end;	// As in 'stack' (can use stack macros).
  unsigned *propagate;		// Position of next literal to propagate.
};

struct averages			// Exponential moving averages.
{
  double conflict_level;	// Slow moving average of conflict level.
  double slow_glue;		// Slow moving average of glue.
  double slow_exp;		// Cached 'slow_beta^n'.
#ifndef NRESTART
  double fast_glue;		// Fast moving average of glue.
  double fast_exp;		// Cached 'fast_beta^n'.
#endif
};

// We use this idiom of defining at compile time a list of code parameters
// multiple times (here 'PROFILES', but also see 'REPORTS' below and
// 'SIGNALS' in 'main.c').  The idea is that the parameter list contains the
// variations of some common code, that is compile time parameters of that
// code.  Here for example the common code will be in the 'PROFILE' macro
// (singular) which then is instantiated with its single parameter (we use
// 'NAME') if just write 'PROFILES'.  The main point is that we can use that
// parameter in 'PROFILE' at compile both as symbol as well as string (with
// '#NAME'), or even generate new symbols (see 'SIGNALS' in 'main.c').

#define PROFILES \
PROFILE (focused) 		/* time spent in focused mode */ \
PROFILE (parse) 		/* time spent parsing */ \
PROFILE (solve) 		/* time spent solving */ \
PROFILE (stable) 		/* time spent in stable mode */ \
PROFILE (total)			/* total time spent */

struct profile
{
  double start, time;		// start time, and total time
  const char *name;		// used in 'print_profiles'
};				// initialized in 'init_profiles'

#define MAX_PROFILES		16

struct profiles
{
#define PROFILE(NAME) \
  struct profile NAME;		// declare all the profiles
  PROFILES
#undef PROFILE
  struct profile *begin[MAX_PROFILES];
  struct profile **end;
};

struct satch
{
  int status;			// UNKNOWN, SATISFIABLE, UNSATISFIABLE
  bool inconsistent;		// empty clause found or derived
  bool iterate;			// report unit learned
#ifndef NSTABLE
  bool stable;			// stable mode (fewer restarts)
#endif
  unsigned level;		// current decision level
  unsigned size;		// number of variables
  size_t capacity;		// allocated variables
  unsigned unassigned;		// number of unassigned variables
  unsigned *levels;		// decision levels of variables
  struct link *links;		// variable links in decision queue
  signed char *values;		// current assignment of literals
  unsigned char *saved;		// saved assignment of a variable
  signed char *marks;		// mark flag of variable
#ifndef NMINIMIZE
  struct unsigned_stack marked;	// marked variables
#endif
  signed char *frames;		// analyzed flag for each level
  struct queue queue;		// variable decision queue
  struct clause **reasons;	// reason clauses of a variable
  struct watches *watches;	// watches of a literal
  struct trail trail;		// assigned literals
  struct analyzed_stack seen;	// analyzed literals
  struct unsigned_stack clause;	// temporary clause
  struct unsigned_stack blocks;	// analyzed decision levels
  struct clauses irredundant;	// current irredundant clauses
#ifndef NLEARN
  struct clauses redundant;	// current redundant clauses
#endif
  struct limits limits;		// limits on restart
#ifndef NSTABLE
  struct reluctant reluctant;	// doubling for stable restart
#endif
  struct options options;	// a few runtime options
#ifndef NSTABLE
  struct averages averages[2];	// exponential moving averages
#else
  struct averages averages;	// exponential moving averages
#endif
  struct statistics statistics;	// statistic counters
  struct profiles profiles;	// built in run-time profiling
#ifndef NDEBUG
  struct int_stack added;	// added external clause
  struct int_stack original;	// copy of all original clauses
  struct checker *checker;	// internal proof checker
#endif
};

/*------------------------------------------------------------------------*/

// Increase and decrease statistic counters.

#define DEC(NAME) \
do { \
  assert (solver->statistics.NAME > 0); \
  solver->statistics.NAME--; \
} while (0)

#define INC(NAME) \
  ( \
    assert (solver->statistics.NAME < UINT64_MAX), \
    ++solver->statistics.NAME \
  )

#define ADD(NAME,DELTA) \
do { \
  assert (UINT64_MAX - (DELTA) >= solver->statistics.NAME); \
  solver->statistics.NAME += (DELTA); \
} while (0)

/*------------------------------------------------------------------------*/

// The number of variables and literals.

#define VARIABLES (solver->size)	// Number of variables.
#define LITERALS (2u*VARIABLES)	// Number of literals.

// We also often need the number of conflicts.

#define CONFLICTS (solver->statistics.conflicts)
#define TICKS (solver->statistics.ticks)

/*------------------------------------------------------------------------*/

// Iterators for global solver data.  They can be used in a similar way as
// range-based for-loops in C++-11.  For instance the idiom
//
//   for (all_variables (idx))
//     ...
//
// The key features of C'99 we use here are local declarations in
// for-loops and the comma operator to assign the range variable as a side
// effect of a 'true' expression.  We use similar code to iterate over
// generic stacks in 'stack.h'.

#define all_variables(IDX) \
  unsigned IDX = 0, END_VARIABLES = VARIABLES; IDX < END_VARIABLES; IDX++

#define all_literals(LIT) \
  unsigned LIT = 0, END_LITERALS = LITERALS; LIT < END_LITERALS; LIT++

#define all_literals_in_clause(LIT,C) \
  unsigned LIT, * P_ ## LIT = (C)->literals, \
                * const END_ ## LIT = P_ ## LIT + (C)->size; \
  (P_ ## LIT != END_ ## LIT) && (LIT = *P_ ## LIT, true); ++P_ ## LIT

#define all_irredundant_clauses(C) \
  all_pointers_on_stack (struct clause, C, solver->irredundant)

#define all_redundant_clauses(C) \
  all_pointers_on_stack (struct clause, C, solver->redundant)

/*------------------------------------------------------------------------*/

// The 'COVER' macro is used for testing and debugging, more precisely for
// the case where full assertion checking (and proof checking) is not
// feasible, but you still want to figure out whether a certain situation
// can happen.  Those conditions 'COND' are thus 'coverage goals', i.e.,
// conditions you want to hit, or situations where you are almost 100% sure
// that they can never happens, but you want to make sure that it does not
// happen maybe accidentally during full runs on a competition set.  Trying
// to cover a certain case during fuzzing is another usage.

#define COVER(COND) \
( \
  (COND) \
  ? \
  \
    ( \
      fflush (stdout), \
      fprintf (stderr, "%s:%ld: %s: Coverage goal `%s' reached.\n", \
	__FILE__, (long) __LINE__, __func__, #COND), \
      abort (), \
      (void) 0 \
    ) \
  : \
    (void) 0 \
)

/*------------------------------------------------------------------------*/

// These declarations provide nice warnings messages if these functions have
// a format string which does not match the type of one of its arguments.

static void fatal_error (const char *fmt, ...)
  __attribute__((format (printf, 1, 2)));

static void message (struct satch *, unsigned, const char *fmt, ...)
  __attribute__((format (printf, 3, 4)));

#ifndef NDEBUG

static void logging_message (struct satch *, const char *fmt, ...)
  __attribute__((format (printf, 2, 3)));

static void logging_clause (struct satch *, struct clause *,
			    const char *fmt, ...)
  __attribute__((format (printf, 3, 4)));

static void logging_temporary (struct satch *, const char *fmt, ...)
  __attribute__((format (printf, 2, 3)));

#endif

/*------------------------------------------------------------------------*/

// Fatal error message printed to '<stderr>' followed by an 'abort' call.

static void
fatal_error (const char *fmt, ...)
{
  va_list ap;
  fputs ("libsatch: fatal error: ", stderr);
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  fputc ('\n', stderr);
  fflush (stderr);
  abort ();
}

static void
out_of_memory (size_t bytes)
{
  fatal_error ("out-of-memory allocating %zu bytes", bytes);
}

static void
message (struct satch *solver, unsigned level, const char *fmt, ...)
{
  if (solver->options.verbose < level)
    return;
  fputs ("c ", stdout);
  va_list ap;
  va_start (ap, fmt);
  vprintf (fmt, ap);
  va_end (ap);
  fputc ('\n', stdout);
  fflush (stdout);
}

// Print nicely formatted '---- [ <name> ] ----- ... ' section start line.

static void
section (struct satch *solver, const char *name)
{
  assert (solver);
  if (solver->statistics.sections)
    fputs ("c\n", stdout);
  INC (sections);
  fputs ("c ---- [ ", stdout);
  fputs (name, stdout);
  fputs (" ] ", stdout);
  for (size_t i = strlen (name); i < 66; i++)
    putc ('-', stdout);
  fputs ("\nc\n", stdout);
  fflush (stdout);
}

#ifndef NDEBUG

// Logging functions are only compiled in debugging mode and then still need
// to be enabled at run-time (with '-l' or 'satch_enable_logging_messages').

// This is the function for default log messages from the 'LOG' macro.

static void
logging_message (struct satch *, const char *, ...)
__attribute__((format (printf, 2, 3)));

static void
logging_clause (struct satch *, struct clause *, const char *, ...)
__attribute__((format (printf, 3, 4)));

// This logging function prints the SAT-competition comment-line prefix 'c',
// the string 'LOG', then the decision level and finally the actual logging
// message, all separated by spaces.

static void
logging_message (struct satch *solver, const char *fmt, ...)
{
  assert (solver->options.logging);
  printf ("c LOG %u ", solver->level);
  va_list ap;
  va_start (ap, fmt);
  vprintf (fmt, ap);
  va_end (ap);
  fputc ('\n', stdout);
  fflush (stdout);
}

// After printing in essence the same message as the basic logging function
// above this clause logging function conveniently prints the type of the
// clause given as argument, its glue (if redundant), its size and literals.

static void
logging_clause (struct satch *solver, struct clause *c, const char *fmt, ...)
{
  assert (solver->options.logging);
  printf ("c LOG %u ", solver->level);
  va_list ap;
  va_start (ap, fmt);
  vprintf (fmt, ap);
  va_end (ap);
  if (c->redundant)
    printf (" redundant glue %u", c->glue);
  else
    printf (" irredundant");
  printf (" size %u clause[%" PRIu64 "]", c->size, c->id);
  for (all_literals_in_clause (lit, c))
    printf (" %u", lit);
  fputc ('\n', stdout);
  fflush (stdout);
}

static void
logging_temporary (struct satch *solver, const char *fmt, ...)
{
  assert (solver->options.logging);
  printf ("c LOG %u ", solver->level);
  va_list ap;
  va_start (ap, fmt);
  vprintf (fmt, ap);
  va_end (ap);
  printf (" size %zu temporary clause", SIZE (solver->clause));
  for (all_elements_on_stack (unsigned, lit, solver->clause))
      printf (" %u", lit);
  fputc ('\n', stdout);
  fflush (stdout);
}

// Log the temporary clause 'solver->clause'.

#define LOG(...) \
do { \
  if (solver->options.logging) \
    logging_message (solver, __VA_ARGS__); \
} while (0)

#define LOGCLS(...) \
do { \
  if (solver->options.logging) \
    logging_clause (solver, __VA_ARGS__); \
} while (0)

#define LOGTMP(...) \
do { \
  if (solver->options.logging) \
    logging_temporary (solver, __VA_ARGS__); \
} while (0)

#else

// Make sure not to include logging code if 'NDEBUG' is defined.

#define LOG(...) do { } while(0)
#define LOGCLS(...) do { } while(0)
#define LOGTMP(...) do { } while(0)

#endif

/*------------------------------------------------------------------------*/

// This is a section of rather Unix specific code which might require some
// porting effort if building on other operating systems.  On the other it
// is only used for diagnostic purposes and in principle can be removed.

// Process time since starting the process.

static double
process_time (void)
{
  struct rusage u;
  double res;
  if (getrusage (RUSAGE_SELF, &u))
    return 0;
  res = u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec;
  res += u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec;
  return res;
}

// The maximum amount of memory used by this process as seen by the system.

static uint64_t
maximum_resident_set_size (void)
{
  struct rusage u;
  if (getrusage (RUSAGE_SELF, &u))
    return 0;
  return ((uint64_t) u.ru_maxrss) << 10;
}

// Current memory used by this process as seen by the system.  This is
// very Linux specific and will probably not work on other Unix systems.

uint64_t
current_resident_set_size (void)
{
  char path[48];
  sprintf (path, "/proc/%" PRIu64 "/statm", (uint64_t) getpid ());
  FILE *file = fopen (path, "r");
  if (!file)
    return 0;
  uint64_t dummy, rss;
  int scanned = fscanf (file, "%" PRIu64 " %" PRIu64 "", &dummy, &rss);
  fclose (file);
  return scanned == 2 ? rss * sysconf (_SC_PAGESIZE) : 0;
}

/*------------------------------------------------------------------------*/

// Computing the percentage or 'relative' average between two numbers is
// very common and always needs to be guarded against division by zero.
// Therefore we factor out this check into two simple function which also
// makes the caller code usually more readable.

static double
percent (double a, double b)
{
  return b ? 100.0 * a / b : 0;
}

static double
relative (double a, double b)
{
  return b ? a / b : 0;
}

/*------------------------------------------------------------------------*/

// Macros and functions to 'START' and 'STOP' profiling a function.
// References to profiles are pushed on the profile stack in order to
// include time spent in a function in case that function is interrupted
// ('START' issued but interrupted without the corresponding 'STOP').

// Having this profiling information printed in optimized code running on a
// full set of benchmarks is very important to find performance regressions.

#define START(NAME) \
  start_profiling (solver, &solver->profiles.NAME)

#define STOP(NAME) \
  stop_profiling (solver, &solver->profiles.NAME, process_time ())

static void
init_profiles (struct satch *solver)
{
  struct profiles *profiles = &solver->profiles;
  profiles->end = profiles->begin;
#define PROFILE(NAME) \
  profiles->NAME.name = #NAME;
  PROFILES
#undef PROFILE
}

static void
start_profiling (struct satch *solver, struct profile *profile)
{
  struct profiles *profiles = &solver->profiles;
  const double start = process_time ();
  profile->start = start;
  assert (profiles->end < profiles->begin + MAX_PROFILES);
  *profiles->end++ = profile;
}

// Starting and stopping a profile has to follow a block structure, i.e.,
// the corresponding 'STOP' has be to called in reverse order of 'START'.
// For instance 'START (A); START (B); ...; STOP (A); STOP (B);' is correct
// but interleaving not ('START (A); START (B); ...; STOP (A); STOP (B);').
// In order to simplify testing and debugging violations of this rule we
// explicitly ask the caller to specify the stopped profile, even though in
// principle it could be derived from the top of the profile stack.

static double
stop_profiling (struct satch *solver, struct profile *profile, double stop)
{
  struct profiles *profiles = &solver->profiles;
  assert (TOP (*profiles) == profile);
  const double time = stop - profile->start;
  profile->time += time;
  (void) POP (*profiles);
  return time;
}

// If interrupted flush all pending unfinished profiles with the current
// process time.  In order to avoid calling 'getrusage' too often in this
// (often critical time constrained) situation we have the current time as
// argument to 'stop_profiling'.

static double
flush_profiles (struct satch *solver)
{
  struct profiles *profiles = &solver->profiles;
  const double stop = process_time ();
  while (!EMPTY (*profiles))
    stop_profiling (solver, TOP (*profiles), stop);
  profiles->total.time = profiles->parse.time + profiles->solve.time;
  return stop;
}

// Printing the profile information first sorts them according to time.
// We use our own bubble-sort since first the number of profiles is small
// and more importantly we do not want to allocate heap memory (usually
// required by implementations of 'qsort') because this function should only
// work with already existing memory. Consider for instance the case where
// it was called from an interrupt handler catching a segmentation fault due
// to out-of-memory.  Then calling an external sorting function might
// trigger another segmentation fault and we will not see the profiling
// information.  This is bad because for an out-of-memory run the profiling
// information might be particularly useful.

static double
print_profiles (struct satch *solver)
{
  // First flush all timing information (pending profiles to be stopped).
  //
  const double stop = flush_profiles (solver);

  section (solver, "profiling");	// As early as possible.

  // Then add all profiles to the (pre-allocated!) profiles stack skipping
  // those without any time spent in it (unless verbose level is larger 1).
  //
  struct profiles *profiles = &solver->profiles;
  const bool verbose = solver->options.verbose > 1;
  assert (EMPTY (*profiles));
#define PROFILE(NAME) \
do { \
    struct profile * profile = &profiles->NAME; \
    if (profile == &profiles->total) \
      break; \
    if (!verbose && !profile->time) \
      break; \
    assert (profiles->end < profiles->begin + MAX_PROFILES); \
    *profiles->end++ =  &profiles->NAME; \
} while (0);
  PROFILES
#undef PROFILE
    // Sort profiles with respect to time used and name as tie breaker.
    //
  const size_t size = SIZE (*profiles);
  for (size_t i = 0; i < size; i++)
    {
      struct profile *p = profiles->begin[i];
      for (size_t j = i + 1; j < size; j++)
	{
	  struct profile *q = profiles->begin[j];
	  if (p->time < q->time ||
	      (p->time == q->time && strcmp (p->name, q->name) > 0))
	    {
	      profiles->begin[i] = q;
	      profiles->begin[j] = p;
	      p = q;
	    }
	}
    }

  // Finally print the profile information in sorted order.
  //
  const double total = profiles->total.time;
  for (size_t i = 0; i < size; i++)
    {
      struct profile *p = profiles->begin[i];
      printf ("c %14.2f  %6.2f %%  %s\n",
	      p->time, percent (p->time, total), p->name);

    }
  fputs ("c ============================================\n", stdout);
  printf ("c %14.2f  %6.2f %%  total\n", total, 100.0);

  return stop;
}

/*------------------------------------------------------------------------*/

static void
print_statistics (struct satch *solver, double seconds)
{
  section (solver, "statistics");
  struct statistics s = solver->statistics;
  const bool verbose = solver->options.verbose > 1;
#define F1 "%-27s"
#define L2 "17"
#define L3 "17"
#define P3 "14"
  if (verbose)
    printf ("c " F1 " %" L2 PRIu64 " %" L3 "s clauses\n", "added:",
	    s.added, "");
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f per second\n", "conflicts:",
	  s.conflicts, relative (s.conflicts, seconds));
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f per conflict\n", "decisions:",
	  s.decisions, relative (s.decisions, s.conflicts));
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f literals\n", "deduced:",
	  s.deduced, relative (s.deduced, s.conflicts));
  if (verbose)
    printf ("c " F1 " %" L2 PRIu64 " %" P3 ".0f %%  added\n", "deleted:",
	    s.deleted, percent (s.deleted, s.added));
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f literals\n", "learned:",
	  s.learned, relative (s.learned, s.conflicts));
#ifndef NMINIMIZE
  printf ("c " F1 " %" L2 PRIu64 " %" P3 ".0f %%  deduced\n", "minimized:",
	  s.minimized, percent (s.minimized, s.deduced));
#endif
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f per second\n", "propagations:",
	  s.propagations, relative (s.propagations, seconds));
#ifndef NREDUCE
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f interval\n", "reductions:",
	  s.reductions, relative (s.conflicts, s.reductions));
#endif
#ifndef NRESTART
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f interval\n", "restarts:",
	  s.restarts, relative (s.conflicts, s.restarts));
#ifndef NSTABLE
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f interval\n", "switched:",
	  s.switched, relative (s.conflicts, s.switched));
#endif
#endif
  printf ("c " F1 " %" L2 PRIu64 " %" L3 ".2f per prop\n", "ticks:",
	  s.ticks, relative (s.ticks, s.propagations));
}

static void
print_resource_usage (struct satch *solver, double seconds)
{
  section (solver, "resources");
  const uint64_t memory = maximum_resident_set_size ();
  printf ("c %-27s %17" PRIu64 " bytes %11.2f MB\n",
	  "memory:", memory, memory / (double) (1 << 20));
  printf ("c %-27s %17s %17.2f seconds\n", "time:", "", seconds);
}

/*------------------------------------------------------------------------*/

// Export internal unsigned literals as external signed literals.

#ifndef NDEBUG

static unsigned
export_literal (unsigned ilit)
{
  const unsigned iidx = INDEX (ilit);
  assert (iidx < (unsigned) INT_MAX - 1);
  const int eidx = iidx + 1;
  const int elit = SIGN (ilit) ? -eidx : eidx;
  return elit;
}

#endif

/*------------------------------------------------------------------------*/

// Allocate the actual clause data memory and depending on whether we embed
// the literals directly into the clause using a flexible array member just
// allocate one chunk of memory or otherwise the literals separately.

// Interestingly enough the number of bytes needed to store a clause of the
// given size (and its literals) can be calculated with the following
// identical code, even though for the non-embedded variant the result will
// be bigger since it has to include the pointer to the actual literals.

static size_t
bytes_clause (size_t size)
{
  return sizeof (struct clause) + size * sizeof (unsigned);
}

#ifndef NFLEX

// The embedded variants just allocates one (smaller) chunk of memory.

static struct clause *
allocate_clause (size_t size)
{
  const size_t bytes = bytes_clause (size);
  struct clause *res = malloc (bytes);
  if (!res)
    out_of_memory (bytes);
  return res;
}

#else

// The non-embedded variants has to allocate two memory blocks.

static struct clause *
allocate_clause (size_t size)
{
  const size_t header_bytes = sizeof (struct clause);
  struct clause *res = malloc (header_bytes);
  if (!res)
    out_of_memory (header_bytes);
  const size_t literals_bytes = size * sizeof (unsigned);
  res->literals = malloc (literals_bytes);
  if (!res->literals)
    out_of_memory (literals_bytes);
  return res;
}

#endif

static size_t
deallocate_clause (struct clause *c)
{
  size_t res = bytes_clause (c->size);
#ifdef NFLEX
  free (c->literals);
#endif
  free (c);
  return res;
}

/*------------------------------------------------------------------------*/

static struct clause *
add_clause (struct satch *solver, bool redundant, unsigned glue)
{
  const uint64_t added = INC (added);
  const size_t size = SIZE (solver->clause);
  assert (size > 1);
  struct clause *res = allocate_clause (size);
  res->id = added;
  res->garbage = false;
  res->protected = false;
  res->redundant = redundant;
  res->used = false;
  res->glue = glue;
  res->size = size;
  memcpy (res->literals, solver->clause.begin, size * sizeof (unsigned));
  return res;
}

static struct clause *
new_irredundant_clause (struct satch *solver)
{
  struct clause *res = add_clause (solver, false, 0);
  PUSH (solver->irredundant, res);
  INC (irredundant);
  return res;
}

static struct clause *
new_redundant_clause (struct satch *solver, unsigned glue)
{
  struct clause *res = add_clause (solver, true, glue);
#ifndef NLEARN
  PUSH (solver->redundant, res);
#endif
  INC (redundant);
  return res;
}

static size_t
delete_clause (struct satch *solver, struct clause *c)
{
  INC (deleted);
  LOGCLS (c, "delete");
#if !defined(NDEBUG) && !defined(NLEARN)
  for (all_literals_in_clause (lit, c))
    checker_add (solver->checker, export_literal (lit));
  checker_remove (solver->checker);
#endif
  if (c->redundant)
    DEC (redundant);
  else
    DEC (irredundant);
  return deallocate_clause (c);
}

/*------------------------------------------------------------------------*/

// Watch a literal 'lit' in a clause with blocking literal 'other'.

static void
watch_literal (struct satch *solver, unsigned lit,
	       unsigned blocking, struct clause *c)
{
  struct watches *watches = solver->watches + lit;
  struct watch watch;
#ifndef NBLOCK			// Unless blocking literals are disabled
  watch.size = c->size;		// cache the size of the clause and
  watch.blocking = blocking;	// save the blocking literal too.
  LOGCLS (c, "watching %u blocking %u in", lit, blocking);
#else
  (void) blocking;		// Prevent 'unused parameter' warning.
  LOGCLS (c, "watching %u in", lit);
#endif
  watch.clause = c;		// In any case watch the clause.
  PUSH (*watches, watch);
}

// Watch first two literals in the clause.

static void
watch_clause (struct satch *solver, struct clause *c)
{
  assert (c->size > 1);
  const unsigned lit0 = c->literals[0];
  const unsigned lit1 = c->literals[1];
  watch_literal (solver, lit0, lit1, c);
  watch_literal (solver, lit1, lit0, c);
}

/*------------------------------------------------------------------------*/

static inline void
assign (struct satch *solver, unsigned lit, struct clause *reason)
{
  if (reason)
    LOGCLS (reason, "assign %u reason", lit);
  else if (!solver->level)
    LOG ("assign %u through unit clause %u", lit, lit);
  else
    LOG ("assign %u decision", lit);

  if (!solver->level)
    {
      solver->statistics.fixed++;	// root-level fixed literal (unit)
      assert (solver->statistics.active);
      solver->statistics.active--;
#ifdef NLEARN
      assert (!reason || !reason->redundant);
#endif
      reason = 0;
    }

  const unsigned not_lit = NOT (lit);
  assert (!solver->values[lit]);
  assert (!solver->values[not_lit]);

  // Set value of 'lit' and 'not-lit' independently in order to turn the
  // code to access the value of a literal into a simple array look-up as
  // well, thus it becomes simpler and branch less.
  //
  solver->values[lit] = 1;
  solver->values[not_lit] = -1;

  const unsigned idx = INDEX (lit);

  solver->saved[idx] = SIGN (lit);	// Save value for decision value.
  solver->reasons[idx] = reason;	// Remember reason clause.
  solver->levels[idx] = solver->level;	// Remember decision level.

  // Add literal to the partial assignment in the pre-allocated 'trail'.
  //
  assert (solver->trail.end < solver->trail.begin + VARIABLES);
  *solver->trail.end++ = lit;

  // Used for fast termination check on 'satisfiable' instances.
  //
  assert (solver->unassigned);
  solver->unassigned--;
}

/*------------------------------------------------------------------------*/

// We use 32-bit enqueue time stamps which overflow rather frequently after
// roughly 4 billion enqueue operations.  In this case we just go over all
// variable links in order of the decision queue and assign fresh stamps.
// Even for many variables (the maximum variable index is '(1u<<31) - 2') we
// still need a billion enqueue operations before this triggers and thus the
// accumulated complexity for this operation can be ignored.

static void
restamp_queue (struct satch *solver)
{
  LOG ("restamping indices in decision queue");
  struct queue *queue = &solver->queue;
  struct link *links = solver->links, *link;
  unsigned stamp = 0;
  for (unsigned idx = queue->first; idx != INVALID; idx = link->next)
    {
      link = links + idx;
      assert (stamp < UINT_MAX);
      link->stamp = ++stamp;
    }
  queue->search = queue->last;
  queue->stamp = stamp;
}

// Simple doubly linked list enqueue operation with time stamping.

static void
enqueue (struct satch *solver, unsigned idx)
{
  struct queue *const queue = &solver->queue;
  struct link *const links = solver->links;
  struct link *const link = links + idx;
  const unsigned last = queue->last;
  if (last == INVALID)
    {
      assert (queue->first == INVALID);
      queue->first = idx;
    }
  else
    {
      struct link *const prev = links + last;
      assert (prev->next == INVALID);
      prev->next = idx;
    }
  link->prev = last;
  queue->last = idx;
  link->next = INVALID;

  // Now comes the 'stamping' trick from our SAT'2015 paper which makes sure
  // that time stamps respect queue order and can thus be used to compare in
  // constant time whether an element is to the left or right of the cached
  // search index, which during searching for unassigned decision variables
  // is set to the last decision variable index first and then updated in
  // case a variable right to the cached search index becomes unassigned
  // during backtracking.  This technique makes sure that right to the
  // search index all variables are assigned in the decision queue.  See
  // also the code involving stamps in 'backtrack' and in 'decide'.
  //
  if ((link->stamp = ++queue->stamp))	// Check for overflow.
    {
      LOG ("enqueued variable %u stamped %u", idx, link->stamp);
      const unsigned lit = LITERAL (idx);
      if (!solver->values[lit])
	queue->search = idx;
    }
  else
    restamp_queue (solver);
}

// Simple doubly linked list dequeue operation (no stamping involved).

static void
dequeue (struct satch *solver, unsigned idx)
{
  struct queue *const queue = &solver->queue;
  struct link *const links = solver->links;
  struct link *const link = links + idx;
  const unsigned prev_idx = link->prev;
  const unsigned next_idx = link->next;
  if (prev_idx == INVALID)
    {
      assert (queue->first == idx);
      queue->first = next_idx;
    }
  else
    {
      struct link *const prev = links + prev_idx;
      assert (prev->next == idx);
      prev->next = next_idx;
    }
  if (next_idx == INVALID)
    {
      assert (queue->last == idx);
      queue->last = prev_idx;
    }
  else
    {
      struct link *next = links + next_idx;
      assert (next->prev == idx);
      next->prev = prev_idx;
    }
}

/*------------------------------------------------------------------------*/

// The solver can keep a 'capacity' of allocated variables larger than the
// number 'size' of active variables.  This capacity increases exponentially
// and avoids costly resizing operations of data structures during API
// usage. In stand-alone solver usage the number of variables is fixed and
// thus can be pre-allocated by 'satch_reserve', which avoids any resizing.
// This strategy can of course also be followed through the API if the user
// has a reasonable bound on the number of needed variables.

// This whole section of the code can be simplified substantially if we
// assume a fixed number of variables, which is however usually not possible
// for incremental SAT solving  Therefore we went through the effort to work
// this out even though the solver is not completely incremental yet. At
// the moment the API only allows one call to 'satch_solve' but does not use
// any global data structures. Thus multiple solvers can exists at the same
// in the same process and clauses can be added incrementally without
// forcing the user to define a maximum variable up-front.

// The following macro increases the array 'NAME' in the solver which either
// comes as variable indexed array ('FACTOR==1') or literal indexed array
// ('FACTOR==2'). This reallocation would be more complex to code for signed
// 'int' literals and is one of the reasons we use 'unsigned' literals.

#define RESIZE(FACTOR,NAME) \
do { \
  const size_t size = sizeof *solver->NAME; \
  const size_t old_bytes = FACTOR * (size_t) old_capacity * size; \
  const size_t new_bytes = FACTOR * (size_t) new_capacity * size; \
  void * chunk = calloc (new_bytes, 1); \
  if (!chunk) \
    out_of_memory (new_bytes); \
  memcpy (chunk, solver->NAME, old_bytes); \
  free (solver->NAME); \
  solver->NAME = chunk; \
} while (0)

// In principle we could use an unsigned stack for the trail but we can also
// just pre-allocate it, since it will never contain more literals than the
// number of variables.  In 'C' this allocation will not necessarily occupy
// real memory (in terms of resident set size) even for large instances,
// since for instance Linux would just map those allocate pages to real
// pages on demand.  The pre-allocated trail makes the related code in
// 'assign' and 'boolean_constraint_propagation' more efficient.

static void
resize_trail (struct trail *trail, size_t new_capacity)
{
  assert (new_capacity);
  const size_t size = SIZE (*trail);
  const size_t new_bytes = new_capacity * sizeof (unsigned);
  const unsigned propagate = trail->propagate - trail->begin;
  trail->begin = realloc (trail->begin, new_bytes);
  if (!trail->begin)
    out_of_memory (new_bytes);
  trail->end = trail->begin + size;
  trail->propagate = trail->begin + propagate;
}

// Here we increase the capacity that is the number of allocated data in
// terms of allocated variables while 'increase_size' might just activate
// this data to be used if the number of variables increases (the 'size' of
// the solver) but stays below the allocated capacity.

static void
increase_capacity (struct satch *solver, unsigned new_capacity)
{
  const unsigned old_capacity = solver->capacity;
  LOG ("increasing capacity from %u to %u", old_capacity, new_capacity);
  assert (old_capacity < new_capacity);
  assert (new_capacity <= 1u << 31);
  RESIZE (2, watches);
  RESIZE (1, reasons);
  RESIZE (1, links);
  RESIZE (1, levels);
  RESIZE (2, values);
  RESIZE (1, saved);
  RESIZE (1, marks);
  RESIZE (1, frames);
  resize_trail (&solver->trail, new_capacity);
  solver->capacity = new_capacity;
}

// Activate all variables with index 'old_size,...,new_size-1'.  After
// calling this function there are 'new_size' active variables (except for
// already root-level assigned variables).

static void
increase_size (struct satch *solver, unsigned new_size)
{
  const unsigned old_size = solver->size;
  assert (old_size < new_size);
  const unsigned old_capacity = solver->capacity;
  assert (new_size <= 1u << 31);
  if (new_size > old_capacity)
    {
      unsigned new_capacity;
      if (new_size > 1u << 30)
	new_capacity = 1u << 31;	// Maximum capacity reached.
      else
	{
	  // Otherwise pick as 'new_capacity' the smallest power of two
	  // larger than 'new_size'.  This ensures a geometric increase.
	  //
	  assert (old_capacity <= 1u << 30);
	  new_capacity = 1;

	  while (new_size > new_capacity)
	    {
	      assert (new_capacity <= 1u << 30);
	      new_capacity *= 2;
	    }
	}
      increase_capacity (solver, new_capacity);
    }
  assert (new_size <= solver->capacity);
  LOG ("increase solver size form %u to %u", old_size, new_size);
  const unsigned delta = new_size - old_size;
  solver->size = new_size;
  solver->unassigned += delta;
  solver->statistics.active += delta;
  for (unsigned idx = old_size; idx < new_size; idx++)
    enqueue (solver, idx);
}

/*------------------------------------------------------------------------*/

// Checks whether the imported clause contains a literal and its negation.
// If this is not the case this function also removes duplicated literals.

static bool
imported_clause_trivial_or_satisfied (struct satch *solver)
{
  assert (!solver->level);
  const unsigned *const end_clause = solver->clause.end;
  unsigned *const begin_clause = solver->clause.begin;
  unsigned *q = begin_clause;
  bool trivial = false;
  signed char *const marks = solver->marks;
  const signed char *const values = solver->values;
  for (const unsigned *p = begin_clause; p != end_clause; p++)
    {
      const unsigned lit = *p;
      const signed value = values[lit];
      if (value < 0)
	{
	  LOG ("skipping falsified literal %u", lit);
	  continue;
	}
      if (value > 0)
	{
	  LOG ("found satisfied literal %u", lit);
	  trivial = true;
	  break;
	}
      const unsigned idx = INDEX (lit);
      signed char prev = marks[idx];
      if (SIGN (lit))
	prev = -prev;
      if (prev > 0)
	{
	  LOG ("skipping duplicated literal %u", lit);
	  continue;
	}
      if (prev < 0)
	{
	  LOG ("clause contains both literal %u and its negation %u",
	       NOT (lit), lit);
	  trivial = true;
	  break;
	}
      *q++ = lit;
      const signed char mark = SIGN (lit) ? -1 : 1;
      marks[idx] = mark;
    }
  solver->clause.end = q;
  for (const unsigned *p = begin_clause; p != q; p++)
    marks[INDEX (*p)] = 0;
  return trivial;
}

/*------------------------------------------------------------------------*/

// 'elit' signed external literal (as in API and DIMACS format)
// 'eidx' signed external variable index (in the range '1...INT_MAX')
// 'iidx' unsigned internal variable index (in the range '0...(INT_MAX-1)')
// 'ilit' unsigned internal literal (in the range '0...2*(INT_MAX-1)+1')

static unsigned
import_literal (struct satch *solver, int elit)
{
  assert (elit);
  assert (elit != INT_MIN);	// otherwise '-elit' might be undefined
  const int eidx = abs (elit);
  const unsigned iidx = eidx - 1;
  if (iidx >= solver->size)
    increase_size (solver, iidx + 1);
  unsigned ilit = LITERAL (iidx);
  if (elit < 0)
    ilit = NOT (ilit);
  LOG ("imported external literal %d as internal literal %u", elit, ilit);
  return ilit;
}

/*------------------------------------------------------------------------*/

// Propagating a literal over the clauses in which it occurs negatively,
// more precisely for which its negation is  watched is the hot-spot of
// CDCL solving.  This is pronounced by learning many long clauses.   

static struct clause *
propagate_literal (struct satch *solver, unsigned lit)
{
  LOG ("propagating %u", lit);

  const unsigned not_lit = NOT (lit);
  struct watches *const watches = solver->watches + not_lit;
  signed char *const values = solver->values;

  // We traverse all the watches of the literal 'not_lit' and remove those
  // for which we stop watching the clause (since we found a replacement).
  // The updated watches pointers 'q' follows the traversal pointer 'p'.
  //
  struct watch *q = watches->begin;
  const struct watch *p = q;

  struct clause *conflict = 0;

  const struct watch *const end_watches = watches->end;

  // Approximate the number of cache lines read in 'propagation' only
  // focusing on accessing watch stacks, watches, clauses and assignments.
  //
  uint64_t ticks = 1 + (end_watches - q) / (128 / sizeof *q);

  while (!conflict && p != end_watches)
    {
      struct watch watch = *q++ = *p++;	// Keep watch by default.

      struct clause *clause = watch.clause;
#ifndef NBLOCK
      const unsigned blocking_lit = watch.blocking;
      const signed char blocking_value = values[blocking_lit];

      if (blocking_value > 0)	// No need to access watched clause
	continue;		// since blocking literal true.

      const unsigned size = watch.size;

      // Beside the common case above the next common situation which should
      // have special treatment is propagating binary clause.  Again with
      // the blocking literal stored in the watches stack there is no need
      // to access the actual binary clauses here.
      //
      if (size == 2)
	{
	  if (blocking_value < 0)
	    {
	      LOGCLS (clause, "conflicting");
	      conflict = clause;
	    }
	  else
	    {
	      assert (!blocking_value);
	      assign (solver, blocking_lit, clause);
	      ticks++;
	    }
	}
      else
#endif
	// Handle larger non-binary clause in case blocking literals are
	// enabled or both cases (binary and non-binary clauses) if they are.
	{
#ifdef NBLOCK
	  assert (clause->size > 1);
#else
	  assert (clause->size > 2);
#endif
	  assert (!clause->garbage);

	  unsigned *const literals = clause->literals;

	  // At this point we have to access the large clause. This is the
	  // real hot-spot of the solver.  Up-to 80% of the time can be
	  // spend here in the first pointer access without the blocking
	  // literal idea (and specialized binary clause propagation above).
	  // In the source code below with the assertions above disabled the
	  // first pointer access would be accessing the first literal
	  // 'literals[0]' of the clause.  The main purpose of the 'blocking
	  // literal' idea is to reduce the need for this costly pointer
	  // dereference as much as possible.

	  ticks++;		// We count these accesses.

	  // The two watched literals of a clause are stored as first two
	  // literals but we do not know at which position.  In order to
	  // avoid introducing a 'branch' (if-then-else) we simply use the
	  // trick to compute the XOR of the first two literals and the
	  // watched literal 'not_lit', which gives the other literal.
	  //
	  const unsigned other = literals[0] ^ literals[1] ^ not_lit;
	  const signed char other_value = values[other];

	  // Another common situation is that the other watched literal in
	  // that clause is different from the blocking literal, but is
	  // assigned true.  Then we also can stop here after updating the
	  // blocking literal for this watch to this other literal.
	  //
	  if (other_value > 0)
	    {
#ifndef NBLOCK
	      q[-1].blocking = other;
#endif
	      continue;
	    }

	  // Normalize the position where 'not_lit' sits to position '1'.
	  //
	  literals[0] = other;
	  literals[1] = not_lit;

#ifndef NBLOCK
	  assert (clause->size == size);
#else
	  const unsigned size = clause->size;
#endif
	  const unsigned *const end_literals = literals + size;

	  // Now search for a non-false ('true' or unassigned) replacement
	  // for the watched literal 'not_lit' starting with the third.

	  unsigned replacement = INVALID;
	  signed char replacement_value = -1;

	  unsigned *r;

	  for (r = literals + 2; r != end_literals; r++)
	    {
	      replacement = *r;
	      replacement_value = values[replacement];
	      if (replacement_value >= 0)
		break;
	    }

	  if (replacement_value > 0)	// replacement literal true thus
	    {
#ifndef NBLOCK
	      q[-1].blocking = replacement;	// update blocked literal
#endif
	    }
	  else if (!replacement_value)	// replacement literal unassigned
	    {
	      // This is the most common case.

	      // First log the untouched clause, then stop watching the
	      // originally watched literal by simply 
	      //
	      LOGCLS (clause, "unwatching %u in", not_lit);
	      q--;

	      // Swap watched literal with its replacement.
	      //
	      literals[1] = replacement;
	      *r = not_lit;

	      watch_literal (solver, replacement, other, clause);
	    }
	  else if (other_value)	// Clause conflicting, since
	    // all literals are false!
	    {
	      assert (other_value < 0);
	      LOGCLS (clause, "conflicting");
	      conflict = clause;
	    }
	  else			// All literal false except 'other' which is
	    // unassigned and thus is now assigned.
	    {
	      assert (!other_value);
	      assign (solver, other, clause);
	      ticks++;
	    }
	}
    }

  ADD (ticks, ticks);

  // After a conflicting clause is found we break out of the propagation but
  // then still need to copy the rest of the watches.
  //
  while (p != end_watches)
    *q++ = *p++;
  watches->end = q;

  return conflict;
}

// While the previous function propagates the assignment of one literal, the
// process of boolean constraint propagation (BCP) implemented in the next
// function propagates all assigned literals until a conflict is found or
// all have been propagated.  Note that propagation of a literal might
// produce new assigned literals (beside finding conflicting clauses) and
// thus the following loop can be seen as breadth-first search over the unit
// implied literals of the current assignment.

static struct clause *
boolean_constraint_propagation (struct satch *solver)
{
  struct trail *trail = &solver->trail;
  unsigned *propagate = trail->propagate;
  unsigned *p;

  assert (trail->begin <= propagate);
  assert (propagate <= trail->begin + VARIABLES);

  struct clause *conflict = 0;

  for (p = propagate; !conflict && p != trail->end; p++)
    conflict = propagate_literal (solver, *p);

  solver->trail.propagate = p;
  const unsigned propagated = p - propagate;

  ADD (propagations, propagated);
  ADD (conflicts, !!conflict);	// Add '1' if there is a conflict.

  return conflict;
}

/*------------------------------------------------------------------------*/

static void
backtrack (struct satch *solver, unsigned new_level)
{
  LOG ("backtracking to level %u", new_level);
  assert (new_level <= solver->level);

  struct trail *trail = &solver->trail;
  const unsigned *levels = solver->levels;
  signed char *values = solver->values;

  struct queue *queue = &solver->queue;
  const struct link *const links = solver->links;
#ifdef NLEARN
  struct clause *const *const reasons = solver->reasons;
#endif
  unsigned search = queue->search;
  uint64_t max_stamp = search == INVALID ? 0 : links[search].stamp;

  while (!EMPTY (*trail))
    {
      const unsigned lit = TOP (*trail);
      const unsigned idx = INDEX (lit);
      const unsigned lit_level = levels[idx];
      if (lit_level == new_level)
	break;

      (void) POP (*trail);
      LOG ("unassign %u", lit);
      assert (solver->unassigned < solver->size);
      solver->unassigned++;

      const unsigned not_lit = NOT (lit);
      assert (values[lit] > 0);
      assert (values[not_lit] < 0);
      values[lit] = 0;
      values[not_lit] = 0;
#ifdef NLEARN
      struct clause *reason = reasons[idx];
      if (reason && reason->redundant)
	(void) delete_clause (solver, reason);
#endif
      const uint64_t stamp = links[idx].stamp;
      if (stamp > max_stamp)
	search = idx, max_stamp = stamp;
    }
  LOG ("searched variable index %u", search);
  queue->search = search;

  solver->trail.propagate = trail->end;
  solver->level = new_level;
}

/*------------------------------------------------------------------------*/

// We have fast and slow moving exponential averages all updated during
// conflicting clause analysis.  The slow moving averages are biased
// towards their initial value (zero) and we use a method described in the
// literature (the well known ADAM machine learning paper) to correct the
// bias by multiplying with '1/(1-beta^n)' where 'beta = 1 - alpha' and
// 'alpha' is the smoothing factor (decay) and 'n' is the number of updates
// to the exponential moving average.  The 'alpha's are defined above as
// macros since some compilers will otherwise not allow the following line.

const double slow_beta = 1.0 - slow_alpha;

// We have two sets of independent averages for stable and focused mode.
// During mode switching the 'stable' bit is flipped which makes the other
// set of averages active.  However if stable mode is disabled we only have
// one set of averages and only update and use that.  To hide this logic we
// use the following function which returns the active set of averages.

static struct averages *
averages (struct satch *solver)
{
#ifndef NSTABLE
  return solver->averages + solver->stable;
#else
  return &solver->averages;
#endif
}

static void
update_slow_average (double *average, unsigned value)
{
  *average += slow_alpha * (value - *average);
}

static double
unbiased_slow_average (struct averages *a, double avg)
{
  const double div = 1 - a->slow_exp;
  return !div ? 0 : div == 1 ? avg : avg / div;
}

#ifndef NRESTART

// Only 'restarting' needs a fast moving average ('fast_glue').

const double fast_beta = 1.0 - fast_alpha;

static void
update_fast_average (double *average, unsigned value)
{
  *average += fast_alpha * (value - *average);
}

static double
unbiased_fast_average (struct averages *a, double avg)
{
  const double div = 1 - a->fast_exp;
  return !div ? 0 : div == 1 ? avg : avg / div;
}

#endif

// We assume that all fast and slow moving averages are updated at the same
// time and then just update 'beta^n' for both too.

static void
update_betas (struct satch *solver)
{
  struct averages *a = averages (solver);
#ifndef NRESTART
  if (a->fast_exp)
    a->fast_exp *= fast_beta;
#endif
  if (a->slow_exp)
    a->slow_exp *= slow_beta;
}

static void
init_one_set_of_averages (struct satch *solver, struct averages *a)
{
  a->slow_exp = 1.0;
#ifndef NRESTART
  a->fast_exp = 1.0;
#endif
}

static void
init_averages (struct satch *solver)
{
#ifndef NSTABLE
  init_one_set_of_averages (solver, &solver->averages[0]);
  init_one_set_of_averages (solver, &solver->averages[1]);
#else
  init_one_set_of_averages (solver, &solver->averages);
#endif
}

/*------------------------------------------------------------------------*/

// Sorting the analyzed variable indices to be bumped with respect to their
// stamp makes sure that they keep the same relative order after bumping
// which empirically improves the effectiveness of the decision heuristic
// (less conflicts).  You can disable this optimization at run-time by
// configuring with './configure.sh --no-sorting'.  By default
// 'NSORT' is undefined and thus this sorting heuristic is used.

#ifndef NSORT

// Comparison function for 'qsort' to sort variable indices by stamp time.

static int
cmp_analyzed (const void *p, const void *q)
{
  const struct analyzed *a = p, *b = q;
  unsigned s = a->stamp, t = b->stamp;
  return (s < t) ? -1 : 1;
}

static void
sort_analyzed (struct satch *solver)
{
  qsort (solver->seen.begin, SIZE (solver->seen),
	 sizeof (struct analyzed), cmp_analyzed);
}

#endif

/*------------------------------------------------------------------------*/

#define SEEN 1

#ifndef NMINIMIZE

#define POISONED 2
#define REMOVABLE 4

static bool
minimize_literal (struct satch *solver, unsigned lit, unsigned depth)
{
  const unsigned idx = INDEX (lit);
  signed char mark = solver->marks[idx];
  assert (mark >= 0);
  if (mark & POISONED)
    return false;		// previously shown not to be removable
  if (mark & REMOVABLE)
    return true;		// previously shown to be reomvable
  if (depth && (mark & SEEN))
    return true;		// analyzed thus removable (unless start)
  if (depth > minimize_depth)
    return false;		// avoid deep recursion
  assert (solver->values[lit] < 0);
  struct clause *const reason = solver->reasons[idx];
  if (!reason)
    return false;		// decisions can not be removed
  const unsigned level = solver->levels[idx];
  if (!level)
    return true;		// root-level units can be removed
  if (!solver->frames[level])
    return false;		// decision level not pulled into clause
  LOGCLS (reason, "trying to remove %u at depth %u along", lit, depth);
  const unsigned not_lit = NOT (lit);
  bool res = true;
  for (all_literals_in_clause (other, reason))
    {
      if (other == not_lit)
	continue;
      if (minimize_literal (solver, other, depth + 1))
	continue;
      LOG ("could not remove literal %u", other);
      res = false;
      break;
    }
  if (depth)
    {
      mark |= (res ? REMOVABLE : POISONED);
      solver->marks[idx] = mark;
      PUSH (solver->marked, idx);
    }
  LOG ("removing %u at depth %u %s",
       lit, depth, res ? "succeeded" : "failed");
  return res;
}

static void
minimize_deduced_clause (struct satch *solver)
{
  assert (EMPTY (solver->marked));

  const unsigned *const end = solver->clause.end;
  unsigned *q = solver->clause.begin + 1;

  for (const unsigned *p = q; p != end; p++)
    {
      const unsigned lit = *p;
      LOG ("trying to minimize literal %u", lit);
      if (minimize_literal (solver, lit, 0))
	LOG ("minimized literal %u", lit);
      else
	*q++ = lit;
    }

  const size_t minimized = end - q;
  solver->clause.end = q;

  LOG ("minimized %zu literals", minimized);
  ADD (minimized, minimized);

  for (all_elements_on_stack (unsigned, idx, solver->marked))
      solver->marks[idx] &= SEEN;

  CLEAR (solver->marked);
}

#endif

/*------------------------------------------------------------------------*/

static bool
analyze (struct satch *solver, struct clause *conflict)
{
  assert (!solver->inconsistent);

  const unsigned conflict_level = solver->level;
  if (!conflict_level)
    {
      LOG ("learned empty clause");
      solver->inconsistent = true;
#ifndef NDEBUG
      checker_learned (solver->checker);
#endif
      return false;
    }

  assert (EMPTY (solver->blocks));	// Decision levels analyzed.
  assert (EMPTY (solver->clause));	// Clause learned.
  assert (EMPTY (solver->seen));	// Analyzed literals.

  PUSH (solver->clause, INVALID);	// Reserve room for 1st UIP.

  signed char *const marks = solver->marks;
  const unsigned *const levels = solver->levels;
  struct clause *const *const reasons = solver->reasons;
  signed char *frames = solver->frames;
#ifndef NSORT
  const struct link *const links = solver->links;
#endif
  struct clause *reason = conflict;

  const unsigned *t = solver->trail.end;
  unsigned unresolved_on_current_level = 0;
  unsigned uip;

  for (;;)
    {
      assert (reason);
      LOGCLS (reason, "analyzing");
      reason->used = true;
      for (all_literals_in_clause (lit, reason))
	{
	  const unsigned idx = INDEX (lit);
	  const unsigned lit_level = levels[idx];
	  if (!lit_level)
	    continue;
	  const signed char mark = marks[idx];
	  assert (!mark || mark == SEEN);
	  if (mark)
	    continue;
	  marks[idx] = SEEN;
	  struct analyzed analyzed;
	  analyzed.idx = idx;
#ifndef NSORT
	  analyzed.stamp = links[idx].stamp;
#endif
	  PUSH (solver->seen, analyzed);
	  LOG ("analyzing literal %u", lit);
	  assert (solver->values[lit] < 0);
	  if (lit_level < conflict_level)
	    {
	      if (!frames[lit_level])
		{
		  LOG ("analyzing decision level %u", lit_level);
		  PUSH (solver->blocks, lit_level);
		  frames[lit_level] = 1;
		}
	      PUSH (solver->clause, lit);
	    }
	  else
	    unresolved_on_current_level++;
	}
      do
	{
	  assert (solver->trail.begin < t);
	  uip = *--t;
	}
      while (!marks[INDEX (uip)]);
      if (!--unresolved_on_current_level)
	break;
      reason = reasons[INDEX (uip)];
    }
  LOG ("1st unique implication point %u", uip);
  const unsigned not_uip = NOT (uip);
  ACCESS (solver->clause, 0) = not_uip;

  LOGTMP ("deduced");
  unsigned size = SIZE (solver->clause);
  ADD (deduced, size);
  assert (size);

#ifndef NMINIMIZE
  minimize_deduced_clause (solver);
  LOGTMP ("minimized");
  size = SIZE (solver->clause);
#endif

  const unsigned glue = SIZE (solver->blocks);
  unsigned jump_level = 0;
  for (all_elements_on_stack (unsigned, lit_level, solver->blocks))
    {
      frames[lit_level] = 0;
      if (lit_level != conflict_level && jump_level < lit_level)
	jump_level = lit_level;
    }
  CLEAR (solver->blocks);

  struct averages *a = averages (solver);
#ifndef NRESTART
  update_fast_average (&a->fast_glue, glue);
#endif
  update_slow_average (&a->slow_glue, glue);
  update_slow_average (&a->conflict_level, conflict_level);
  update_betas (solver);

  LOG ("determined jump level %u and glue %u", jump_level, glue);
  LOG ("exponential 'conflict_level' moving average %g",
       unbiased_slow_average (a, a->conflict_level));
#ifndef NRESTART
  LOG ("exponential 'fast_glue' moving average %g",
       unbiased_fast_average (a, a->fast_glue));
#endif
  LOG ("exponential 'slow_glue' moving average %g",
       unbiased_slow_average (a, a->slow_glue));

#ifndef NSORT
  sort_analyzed (solver);
#endif
  for (all_elements_on_stack (struct analyzed, analyzed, solver->seen))
    {
      const unsigned idx = analyzed.idx;
      LOG ("bumping variable %u", idx);
      dequeue (solver, idx);
      enqueue (solver, idx);
      assert (marks[idx]);
      marks[idx] = 0;
    }
  CLEAR (solver->seen);

  backtrack (solver, jump_level);

  if (size == 1)		// Learned a unit clause.
    {
      assert (!jump_level);
      solver->iterate = true;
      assign (solver, not_uip, 0);
    }
  else
    {
      assert (size > 1);	// Learned and at least binary clause.
      assert (jump_level > 0);

      // First literal at jump level becomes other watch.  Such a literal
      // has to exist and thus the 'break' below has to be hit.  We further
      // rely on backtracking not to reset the level of unassigned literals.
      //
      for (unsigned *p = solver->clause.begin + 1, *q = p;; q++)
	{
	  assert (q != solver->clause.end);
	  const unsigned lit = *q, level = levels[INDEX (lit)];
	  assert (level <= jump_level);
	  if (level == jump_level)
	    {
	      *q = *p;
	      *p = lit;
	      break;
	    }
	}

      struct clause *learned = new_redundant_clause (solver, glue);
      LOGCLS (learned, "learned");
      ADD (learned, size);
#ifndef NLEARN
      watch_clause (solver, learned);
#endif
      assign (solver, not_uip, learned);
    }

#ifndef NDEBUG
  for (all_elements_on_stack (unsigned, lit, solver->clause))
      checker_add (solver->checker, export_literal (lit));
  checker_learned (solver->checker);
#endif
  CLEAR (solver->clause);

  return true;
}

/*------------------------------------------------------------------------*/

static void
decide (struct satch *solver)
{
  INC (decisions);

  assert (solver->unassigned);
  assert (!solver->inconsistent);

  const struct link *const links = solver->links;
  const signed char *const values = solver->values;
  struct queue *queue = &solver->queue;

  unsigned idx = queue->search, lit;

  for (;;)
    {
      assert (idx != INVALID);
      lit = LITERAL (idx);
      const signed char value = values[lit];
      if (!value)
	break;
      idx = links[idx].prev;
    }
  queue->search = idx;		// Cache search position.

  assert (solver->level < solver->size);
  solver->level++;
  LOG ("decision variable %u stamped %u", idx, links[idx].stamp);

  // Assign to saved previously assigned value.
  //
  const unsigned decision = lit ^ solver->saved[idx];
  assign (solver, decision, 0);
}

/*------------------------------------------------------------------------*/

// Report verbose message lines listing the following statistics. We use the
// same trick as for signal handlers in 'main.c' of listing all the
// different reported statistics as 'REPORT' item in the macro 'REPORTS'.
// Then we redefine 'REPORT' to instantiate 'REPORTS' accordingly.

#define REPORTS \
REPORT(seconds, "%.2f") \
REPORT(MB, "%.0f") \
REPORT(level, "%.0f") \
REPORT_IF_STABLE(switched, "%" PRIu64) \
REPORT_IF_REDUCE(reductions, "%" PRIu64) \
REPORT_IF_RESTART(restarts, "%" PRIu64) \
REPORT(conflicts, "%" PRIu64) \
REPORT_IF_LEARN(redundant, "%" PRIu64) \
REPORT(glue, "%.0f") \
REPORT(irredundant, "%" PRIu64) \
REPORT(variables, "%u") \
REPORT(remaining, "%.0f%%")

// Need to exclude 'restart' and 'reduce' reports if disabled.

#define DO_NO_REPORT(A,B) /**/
#ifdef NLEARN
#define REPORT_IF_LEARN DO_NO_REPORT
#else
#define REPORT_IF_LEARN REPORT
#endif
#ifdef NRESTART
#define REPORT_IF_RESTART DO_NO_REPORT
#else
#define REPORT_IF_RESTART REPORT
#endif
#ifdef NREDUCE
#define REPORT_IF_REDUCE DO_NO_REPORT
#else
#define REPORT_IF_REDUCE REPORT
#endif
#ifdef NSTABLE
#define REPORT_IF_STABLE DO_NO_REPORT
#else
#define REPORT_IF_STABLE REPORT
#endif
#define MAX_HEADER	3	// Number of header lines.
#define MAX_LINE	256	// Maximum expected line length.
#define MAX_REPORTS	16	// Maximum number of reported values.
  static void
report (struct satch *solver, int type)
{
  if (!solver->options.verbose)
    return;

  INC (reported);

  // If you want to print a certain statistic you need to add a line to the
  // 'REPORTS' macro above but also define a matching local constant here.

  struct averages *a = averages (solver);
  const double seconds = process_time ();
  const double MB = current_resident_set_size () / (double) (1 << 20);
  const double level = unbiased_slow_average (a, a->conflict_level);
#ifndef NSTABLE
  const uint64_t switched = solver->statistics.switched;
#endif
#ifndef NREDUCE
  const uint64_t reductions = solver->statistics.reductions;
#endif
#ifndef NRESTART
  const uint64_t restarts = solver->statistics.restarts;
#endif
  const uint64_t conflicts = CONFLICTS;
#ifndef NLEARN
  const uint64_t redundant = solver->statistics.redundant;
#endif
  const double glue = unbiased_slow_average (a, a->slow_glue);
  const uint64_t irredundant = solver->statistics.irredundant;
  const unsigned variables = solver->statistics.active;
  double remaining = percent (variables, solver->size);

  // Prepare

  int num_reported = 0;		// Number of reported values.

  int column[MAX_REPORTS];	// Save start of columns to format headers.
  char line[MAX_LINE];		// Actual line of values printed.
  int end_line = 0;		// End of the value line.

  line[end_line++] = 'c';

  // The value line has the following two characters less space than the
  // header lines which makes some room for the first header to stick out to
  // the left (this is also necessary for the 'seconds' header).

  line[end_line++] = ' ';
  line[end_line++] = type;

  // Print values to 'line' remembering starting positions and widths.

#define REPORT(NAME,FMT) \
  { \
    assert (end_line < MAX_LINE); \
    line[end_line++] = ' '; \
    column[num_reported++] = end_line; \
    char buffer[32]; \
    sprintf (buffer, FMT, NAME); \
    for (const char * p = buffer; *p; p++) \
      assert (end_line < MAX_LINE), \
      line[end_line++] = *p; \
  }
  REPORTS
#undef REPORT
    // Initially and after 16 rows without printing a header we print one.
    // This gives 20 rows with 3 header lines (and one empty line) which
    // perfectly matches typical terminal height.
    if ((solver->statistics.reported % 16) == 1)
    {
      char header[MAX_HEADER][MAX_LINE];
      int end_header[MAX_HEADER];

      for (int i = 0; i < MAX_HEADER; i++)
	{
	  header[i][0] = 'c';
	  end_header[i] = 1;
	}

      int reported = 0;

      // This is the really trick part to get a nicely adjusted header to
      // the columns of values which vary in size.  Goal is to keep the
      // column names in the middle above the values split in different
      // header rows so that they do not overlap.

#define REPORT(NAME, FMT) \
      { \
        const int row = reported % MAX_HEADER; \
	assert (end_header[row] < MAX_LINE); \
	header[row][end_header[row]++] = ' '; \
	assert (reported < num_reported); \
	const int start = column[reported++]; \
	const int end = \
	  (reported == num_reported ? end_line : column[reported]); \
	const int value_width = end - start - 1; \
	const int name_width = strlen (#NAME); \
	int target; \
	if (name_width > value_width) \
	  target = start - (name_width - value_width + 1)/2; \
	else \
	  target = start + (value_width - name_width + 1)/2; \
	assert (target <= MAX_LINE); \
	while (end_header[row] < target) \
	  { \
	    assert (end_header[row] < MAX_LINE); \
	    header[row][end_header[row]++] = ' '; \
	  } \
	for (const char * p = #NAME; *p; p++) \
	  { \
	    assert (end_header[row] < MAX_LINE); \
	    header[row][end_header[row]++] = *p; \
	  } \
      }
      REPORTS
#undef REPORT
	fputs ("c\n", stdout);
      for (int i = 0; i < MAX_HEADER; i++)
	{
	  for (int j = 0; j < end_header[i]; j++)
	    fputc (header[i][j], stdout);
	  fputc ('\n', stdout);
	}
      fputs ("c\n", stdout);
    }

  for (int i = 0; i < end_line; i++)
    fputc (line[i], stdout);
  fputc ('\n', stdout);
  fflush (stdout);
}

// Report statistics after unit clause has been learned and propagated.

static void
iterate (struct satch *solver)
{
  report (solver, 'i');
  solver->iterate = false;
}

/*------------------------------------------------------------------------*/

// Scaling functions used for scaling conflict intervals.

#if !defined(NREDUCE) || !defined(NRESTART)

static double
logn (uint64_t n)
{
  return log10 (n + 10);
}

#if !defined(NSTABLE)

static double
nlognlognlogn (uint64_t n)
{
  double tmp = log10 (n + 10);
  return n * tmp * tmp * tmp;
}

#endif

#endif

#if !defined(NREDUCE)

static double
ndivlogn (uint64_t n)
{
  return n / logn (n);
}

#endif

/*------------------------------------------------------------------------*/

// Restarts are in principle triggered by restart intervals (measured in the
// number of conflicts passed).   However in focused mode we use exponential
// moving averages of the glucose level (glue) of learned clauses to
// determine whether we are in a phase where those levels go downward or
// increase.  If the glue goes down we do not restart but if it goes up,
// that is the fast moving average is above a certain margin of the slower
// moving average, we do restart.

#ifndef NRESTART

static bool
restarting (struct satch *solver)
{
  if (!solver->level)
    return false;
  if (solver->limits.restart > CONFLICTS)
    return false;

#ifndef NSTABLE
  // Use only (large) conflict intervals in stable mode to trigger restarts.
  // However during computing the next restart limit below we use a
  // reluctant doubling of the base restart interval (also called Luby).
  //
  if (solver->stable)
    return true;
#endif
  struct averages *a = averages (solver);

  const double fast = unbiased_fast_average (a, a->fast_glue);
  const double slow = unbiased_slow_average (a, a->slow_glue);

  const double limit = restart_margin * slow;

  return fast > limit;
}

static void
restart (struct satch *solver)
{
  const uint64_t restarts = INC (restarts);
  message (solver, 4, "[restart-%" PRIu64 "] "
	   "limit %" PRIu64 " hit after %" PRIu64 " conflicts",
	   restarts, solver->limits.restart, CONFLICTS);
  if (solver->options.verbose > 2)
    report (solver, 'r');

  backtrack (solver, 0);

  uint64_t interval;
#ifndef NSTABLE
  if (solver->stable)
    {
      // This is the approach of Donald Knuth to compute the 'reluctant
      // doubling' sequence. In other solvers it is called 'Luby' sequence.
      // We further use a much longer base interval than in focused mode.
      //
      struct reluctant *r = &solver->reluctant;
      uint64_t u = r->u, v = r->v;

      // The base interval is multiplied with the reluctant doubling
      // sequence number (1,2,1,1,2,4,1,1,2,4,8,1,1,2,1,1,2,4,1,1,...).
      //
      interval = v * stable_restart_interval;

      if ((u & -u) == v)
	u++, v = 1;
      else
	assert (UINT64_MAX / 2 >= v), v *= 2;
      r->u = u, r->v = v;
    }
  else
#endif
    interval = (restart_interval - 1) + logn (restarts);

  solver->limits.restart = CONFLICTS + interval;

  message (solver, 4, "[restart-%" PRIu64 "] "
	   "new restart limit %" PRIu64 " conflicts after %" PRIu64,
	   restarts, solver->limits.restart, interval);
}

#endif

/*------------------------------------------------------------------------*/

// Reducing the clause data base by removing useless redundant clauses is
// important to keep the memory usage of the solver low, but also to
// speed-up propagation.  The reduction interval in terms of conflicts is
// increased arithmetically by 'reduce_interval'.  We combine reductions
// with clause data base simplifications which remove root-level satisfied
// clauses.  Removing falsified literals is not implemented yet.

#ifndef NREDUCE

static bool
reducing (struct satch *solver)
{
  return solver->limits.reduce.conflicts <= CONFLICTS;
}

// Protect reason clauses from garbage collection. The same function can
// be used afterwards to make reason clauses unprotected again.  It is
// better to lazily protect clauses during reductions instead of eagerly
// setting the 'protect' bit during assignments to avoid dereferencing
// pointers to binary clause reasons.

static void
set_protect_flag_of_reasons (struct satch *solver, bool protect)
{
  struct clause *const *const reasons = solver->reasons;
  for (all_elements_on_stack (unsigned, lit, solver->trail))
    {
      const unsigned idx = INDEX (lit);
      struct clause *reason = reasons[idx];
      if (reason)
	{
	  LOGCLS (reason, "%sprotecting", protect ? "" : "un");
	  assert (reason->protected != protect);
	  reason->protected = protect;
	}
    }
}

static bool
clause_root_level_satisfied (struct satch *solver, struct clause *c)
{
  const signed char *const values = solver->values;
  const unsigned *const levels = solver->levels;
  for (all_literals_in_clause (lit, c))
    if (values[lit] > 0 && !levels[INDEX (lit)])
      return true;
  return false;
}

// Irredundant clauses are not reduced but root-level satisfied clauses
// can be collected during reduction too.  This is only necessary if there
// are new root-level fixed variables since the last reduction though.

static void
mark_satisfied_irredundant_clauses_as_garbage (struct satch *solver)
{
  for (all_irredundant_clauses (c))
    {
      assert (!c->redundant);
      assert (!c->garbage);
      if (c->protected)
	continue;
      if (!clause_root_level_satisfied (solver, c))
	continue;
      LOGCLS (c, "root-level satisfied thus marked garbage");
      assert (!c->garbage);
      c->garbage = true;
    }
}

// Redundant clauses with large enough glucose level (glue) which have not
// been used since the last reduction are deletion candidates. If there
// are new root-level fixed variables since the last reduction we also
// mark clauses as garbage which are root-level satisfied too.

static void
gather_reduce_candidates (struct satch *solver, bool new_fixed_variables,
			  struct clauses *candidates)
{
  for (all_redundant_clauses (c))
    {
      assert (c->redundant);
      assert (!c->garbage);
      if (c->protected)
	continue;
      if (new_fixed_variables && clause_root_level_satisfied (solver, c))
	{
	  LOGCLS (c, "root-level satisfied thus marked garbage");
	  c->garbage = true;
	  continue;
	}
      const bool used = c->used;
      c->used = false;
      if (used)
	continue;
      if (c->glue <= reduce_glue_limit)
	continue;
      PUSH (*candidates, c);
    }

  if (solver->options.verbose < 2)
    return;

  const size_t size_candidates = SIZE (*candidates);
  const size_t redundant = SIZE (solver->redundant);
  message (solver, 2, "[reduced-%" PRIu64 "] "
	   "gathered %zu reduce candidate clauses %.0f%%",
	   solver->statistics.reductions,
	   size_candidates, percent (size_candidates, redundant));
}

// Before actually deleting the garbage clauses we of course have to
// flush watches from the watcher lists pointing to such garbage clauses.

static void
flush_garbage_watches (struct satch *solver)
{
  struct watches *all_watches = solver->watches;
  for (all_literals (lit))
    {
      struct watches *const lit_watches = all_watches + lit;
      struct watch *const end = lit_watches->end;
      struct watch *q = lit_watches->begin;
      for (struct watch * p = q; p != end; p++)
	{
	  struct watch watch = *q++ = *p;
	  if (watch.clause->garbage)
	    q--;
	}
      lit_watches->end = q;
    }
}

// After removing garbage watches we can finally delete garbage clauses.

static void
delete_garbage_clauses (struct satch *solver, struct clauses *clauses,
			size_t *bytes_ptr, size_t *count_ptr)
{
  size_t bytes = 0;
  size_t count = 0;

  struct clause *const *const end = clauses->end;
  struct clause **q = clauses->begin;

  for (struct clause ** p = q; p != end; p++)
    {
      struct clause *const c = *p;
      if (c->garbage)
	{
	  assert (!c->protected);
	  bytes += delete_clause (solver, c);
	  count++;
	}
      else
	*q++ = c;
    }
  clauses->end = q;

  *bytes_ptr += bytes;
  *count_ptr += count;
}

// Comparison function for 'qsort' to order reduce candidate clauses by
// smaller glue first and then smaller size.  We are using 'qsort' which
// is not stable and thus might produce different results for different
// 'qsort' implementations.  To avoid this potential diverging behaviour
// of different implementations of 'qsort' we have 'id's in clauses and
// use those as deterministic tie breaker.

static int
cmp_reduce_candidates (const void *p, const void *q)
{
  const struct clause *const c = *(struct clause * const *) p;
  const struct clause *const d = *(struct clause * const *) q;
  assert (c != d);
  if (c->glue < d->glue)
    return -1;
  if (c->glue > d->glue)
    return 1;
  if (c->size < d->size)
    return -1;
  if (c->size > d->size)
    return 1;
  assert (c->id != d->id);
  if (c->id < d->id)
    return 1;
  assert (c->id > d->id);
  return -1;
}

static void
sort_reduce_candidates (struct satch *solver, struct clauses *candidates)
{
  qsort (candidates->begin, SIZE (*candidates), sizeof (struct clause *),
	 cmp_reduce_candidates);
}

static void
mark_garbage_candidates (struct satch *solver, struct clauses *candidates)
{
  const size_t size = SIZE (*candidates);
  const size_t target = (1 - reduce_fraction) * size;

  while (SIZE (*candidates) > target)
    {
      struct clause *c = POP (*candidates);
      LOGCLS (c, "reducing thus marked garbage");
      assert (!c->protected);
      assert (!c->garbage);
      c->garbage = true;
    }
}

static void
reduce (struct satch *solver)
{
  const uint64_t reductions = INC (reductions);

  assert (solver->statistics.redundant == SIZE (solver->redundant));
  assert (solver->statistics.irredundant == SIZE (solver->irredundant));

  set_protect_flag_of_reasons (solver, true);

  const bool new_fixed_variables =
    solver->limits.reduce.fixed < solver->statistics.fixed;
  if (new_fixed_variables)
    mark_satisfied_irredundant_clauses_as_garbage (solver);

  struct clauses candidates;
  INIT (candidates);
  gather_reduce_candidates (solver, new_fixed_variables, &candidates);
  sort_reduce_candidates (solver, &candidates);
  mark_garbage_candidates (solver, &candidates);
  RELEASE (candidates);

  flush_garbage_watches (solver);

  size_t bytes = 0, count = 0;
  if (new_fixed_variables)
    delete_garbage_clauses (solver, &solver->irredundant, &bytes, &count);
  delete_garbage_clauses (solver, &solver->redundant, &bytes, &count);

  set_protect_flag_of_reasons (solver, false);

  solver->limits.reduce.fixed = solver->statistics.fixed;

  const uint64_t interval = reduce_interval * ndivlogn (reductions);
  solver->limits.reduce.conflicts = CONFLICTS + interval;

  LOG ("next reduce limit at %" PRIu64 " conflicts after %" PRIu64,
       solver->limits.reduce.conflicts, interval);

  message (solver, 2, "[reduced-%" PRIu64 "] "
	   "collected %zu clauses (%zu bytes, %.0f MB)",
	   reductions, count, bytes, bytes / (double) (10 << 20));

  report (solver, '-');
}

#endif

/*------------------------------------------------------------------------*/

#ifndef NSTABLE

static void
start_mode (struct satch *solver)
{
  if (solver->stable)
    {
      START (stable);
      report (solver, '[');
    }
  else
    {
      START (focused);
      report (solver, '{');
    }
}

static void
stop_mode (struct satch *solver)
{
  if (solver->stable)
    {
      STOP (stable);
      report (solver, ']');
    }
  else
    {
      STOP (focused);
      report (solver, '}');
    }
}

static bool
switching (struct satch *solver)
{
  if (solver->stable)
    return solver->limits.mode.ticks <= TICKS;
  else
    return solver->limits.mode.conflicts <= CONFLICTS;
}

static void
switch_mode (struct satch *solver)
{
  const uint64_t switched = INC (switched);
  stop_mode (solver);
  if (solver->stable)
    {
      solver->stable = false;
      assert (switched >= 2);
      assert (!(switched & 1));

      const uint64_t conflicts = mode_interval * nlognlognlogn (switched / 2);
      solver->limits.mode.conflicts = CONFLICTS + conflicts;
      solver->limits.mode.ticks = TICKS;

      solver->limits.restart = CONFLICTS + restart_interval;
    }
  else
    {
      solver->stable = true;
      assert ((switched & 1));

      assert (TICKS <= solver->statistics.ticks);
      const uint64_t focused_ticks = TICKS - solver->limits.mode.ticks;
      solver->limits.mode.ticks = TICKS + focused_ticks;

      solver->reluctant.u = solver->reluctant.v = 1;
      solver->limits.restart = CONFLICTS + stable_restart_interval;
    }
  start_mode (solver);
}

#endif

/*------------------------------------------------------------------------*/

static void
init_limits (struct satch *solver)
{
#ifndef NREDUCE
  solver->limits.reduce.conflicts = reduce_interval;
#endif
#ifndef NRESTART
  solver->limits.restart = restart_interval;
#ifndef NSTABLE
  assert (!solver->stable);
  solver->limits.mode.conflicts = mode_interval;
#endif
#endif
}

/*------------------------------------------------------------------------*/

// This is the main CDCL solving loop.

static int
solve (struct satch *solver)
{
  START (solve);
  report (solver, '*');

  int res = solver->inconsistent ? 20 : 0;
  struct clause *conflict;

#ifndef NSTABLE
  start_mode (solver);
#endif
  while (!res)
    if ((conflict = boolean_constraint_propagation (solver)))
      {
	if (!analyze (solver, conflict))
	  res = 20;
      }
    else
      {
	if (solver->iterate)
	  iterate (solver);

	if (!solver->unassigned)
	  res = 10;
	else
	  {
#ifndef NRESTART
	    if (restarting (solver))
	      restart (solver);
#ifndef NSTABLE
	    else if (switching (solver))
	      switch_mode (solver);
#endif
#endif
#ifndef NREDUCE
	    if (reducing (solver))
	      reduce (solver);
#endif
	    decide (solver);
	  }
      }
#ifndef NSTABLE
  stop_mode (solver);
#endif

  report (solver, !res ? '?' : res == 10 ? '1' : '0');
  STOP (solve);

  return res;
}

/*------------------------------------------------------------------------*/

#ifndef NDEBUG

// This witness checker goes over the saved original clauses and checks that
// each of them is satisfied.  If not a fatal error message is triggered
// after printing the original clause which is unsatisfied.

static void
check_witness (struct satch *solver)
{
  const int *const begin_original = solver->original.begin;
  const int *const end_original = solver->original.end;
  size_t clauses = 0;
  for (const int *p = begin_original, *c = p; c != end_original; c = p)
    {
      clauses++;
      bool satisfied = false;
      int lit;
      while (assert (p != end_original), (lit = *p++))
	if (satch_val (solver, lit) == lit)
	  satisfied = true;
      if (satisfied)
	continue;
      fprintf (stderr,
	       "libsatch: fatal error: clause[%zd] unsatisfied:\n", clauses);
      for (const int *q = c; q != p; q++)
	printf (" %d", *q);
      fputc ('\n', stderr);
      fflush (stderr);
      abort ();
    }
  LOG ("checked witness successfully");
}

#endif

/*------------------------------------------------------------------------*/

// The API functions below have several requirements (contracts) and those
// need to be enforced even in optimized code, particularly in order to help
// library users to detect, test and debug wrong API usage.

static void
invalid_usage (const char *message, const char *function)
{
  fprintf (stderr,
	   "libsatch: invalid API usage in '%s': %s\n", function, message);
  fflush (stderr);
  abort ();
}

// Macros to enforce valid API usage.

#define REQUIRE(CONDITION,MESSAGE) \
do { \
  if (!(CONDITION)) \
    invalid_usage (MESSAGE, __func__); \
} while (0)

#define REQUIRE_NON_ZERO_SOLVER() \
  REQUIRE (solver, "zero solver argument")

#define REQUIRE_VALID_LITERAL(ELIT) \
do { \
  REQUIRE ((ELIT) != INT_MIN, "'INT_MIN' literal argument"); \
} while (0)

#define REQUIRE_NON_ZERO_VALID_LITERAL(ELIT) \
do { \
  REQUIRE ((ELIT), "zero literal argument"); \
  REQUIRE ((ELIT) != INT_MIN, "'INT_MIN' literal argument"); \
} while (0)

/*========================================================================*/
//    Below are the non-static functions accessible through the API.      //
/*========================================================================*/

struct satch *
satch_init (void)
{
  struct satch *solver = calloc (1, sizeof (struct satch));
  if (!solver)
    fatal_error ("could not allocate solver");
  solver->queue.first = solver->queue.last = solver->queue.search = INVALID;
#ifndef NDEBUG
  solver->checker = checker_init ();
#endif
  init_averages (solver);
  init_limits (solver);
  init_profiles (solver);
  return solver;
}

void
satch_release (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
#ifdef NLEARN
  if (solver->level)
    backtrack (solver, 0);	// To delete reason clauses.
#endif
  free (solver->levels);
  free (solver->links);
  free (solver->values);
  free (solver->saved);
  free (solver->marks);
  free (solver->frames);
  free (solver->reasons);
  free (solver->trail.begin);
  for (all_literals (lit))
    RELEASE (solver->watches[lit]);
  free (solver->watches);
#ifndef NMINIMIZE
  RELEASE (solver->marked);
#endif
  RELEASE (solver->seen);
  RELEASE (solver->clause);
  RELEASE (solver->blocks);
  for (all_pointers_on_stack (struct clause, c, solver->irredundant))
      (void) delete_clause (solver, c);
  RELEASE (solver->irredundant);
#ifndef NLEARN
  for (all_pointers_on_stack (struct clause, c, solver->redundant))
      (void) delete_clause (solver, c);
  RELEASE (solver->redundant);
#endif
  assert (!solver->statistics.irredundant);
  assert (!solver->statistics.redundant);
#ifndef NDEBUG
  RELEASE (solver->added);
  RELEASE (solver->original);
#ifndef NLEARN
  checker_enable_leak_checking (solver->checker);
#endif
  checker_release (solver->checker);
#endif
  free (solver);
}

/*------------------------------------------------------------------------*/

// Add a literal to an internal temporary clause or if the literal argument
// is zero then add a new irredundant / original clause to the solver which
// consists of all the previously literals added to the temporary clause.

void
satch_add (struct satch *solver, int elit)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_VALID_LITERAL (elit);
  REQUIRE (!solver->status, "incremental usage not implemented yet");
#ifndef NDEBUG
  PUSH (solver->original, elit);
#endif

  if (solver->inconsistent)
    return;			// No need to add anything.

  if (elit)
    {
      // Add the literal to internal temporary 'clause' after importing the
      // literal, i.e., adjusting the 'size' (number of active variables) if
      // its variable has never been seen before.  Also turn the external
      // signed DIMACS 'int' literals into and internal 'unsigned' literal.
      //
      const unsigned ilit = import_literal (solver, elit);
      PUSH (solver->clause, ilit);
#ifndef NDEBUG
      checker_add (solver->checker, elit);
      PUSH (solver->added, elit);
#endif
    }
  else
    {
#ifndef NDEBUG
      checker_original (solver->checker);
      bool remove_original_clause_from_checker;
#endif
      // First check whether the imported clause is already (root-level)
      // satisfied or trivial (contains both a literal and its negation).
      // During this check falsified and duplicated literals are removed.
      //
      if (!imported_clause_trivial_or_satisfied (solver))
	{
	  // We need special treatment for empty and unary clauses since all
	  // internally allocated clauses have at least two literals.  
	  //
	  const size_t size = SIZE (solver->clause);

	  if (!size)
	    {
	      LOG ("empty thus inconsistent imported clause");
	      solver->inconsistent = true;
	    }
	  else if (size == 1)
	    {
	      // It is a common technique to represent unit clauses by just
	      // assigning its literal on the root-level.  This makes sure
	      // that all allocated clauses are at least binary, but for
	      // instance requires that 'analyze' treats root-level literals
	      // in a special way, 'reduce' and thus 'assign', ignore
	      // clauses forcing root-level assigned literals and finally
	      // (and maybe really the most severe consequence), makes proof
	      // tracing semantics rather complex (particularly regarding the
	      // situation of deleting unit clauses in RUP / DRAT proofs).

	      const unsigned unit = ACCESS (solver->clause, 0);
	      const signed char value = solver->values[unit];
	      if (value > 0)
		{
		  LOG ("skipping redundant unit clause %u", unit);
		}
	      else if (value < 0)
		{
		  LOG ("found inconsistent unit clause %u", unit);
		  solver->inconsistent = true;
		}
	      else
		{
		  LOG ("found unit clause %u", unit);
		  assign (solver, unit, 0);
		}
	    }
	  else
	    {
	      struct clause *clause = new_irredundant_clause (solver);
	      LOGCLS (clause, "imported");
	      watch_clause (solver, clause);
	    }
#ifndef NDEBUG
	  const size_t added = SIZE (solver->added);
	  assert (size <= added);
	  if (size < added)
	    {
	      for (all_elements_on_stack (unsigned, lit, solver->clause))
		  checker_add (solver->checker, export_literal (lit));
	      checker_learned (solver->checker);

	      remove_original_clause_from_checker = true;
	    }
	  else
	    remove_original_clause_from_checker = false;
#endif
	}
#ifndef NDEBUG
      else
	remove_original_clause_from_checker = true;
#endif
      CLEAR (solver->clause);
#ifndef NDEBUG
      if (remove_original_clause_from_checker)
	{
	  for (all_elements_on_stack (int, lit, solver->added))
	      checker_add (solver->checker, lit);
	  checker_remove (solver->checker);
	}
      CLEAR (solver->added);
#endif
    }
}

/*------------------------------------------------------------------------*/

// Reserve at least 'max_var' variables that is the size of the solver. If
// the users knows this number then pre-allocating everything to that size
// avoid resizing the solver data.

void
satch_reserve (struct satch *solver, int max_var)
{
  REQUIRE_NON_ZERO_SOLVER ();
  assert (0 <= max_var);
  const size_t requested_capacity = max_var;
  if (requested_capacity > solver->capacity)
    increase_capacity (solver, requested_capacity);
}

int
satch_maximum_variable (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  assert (solver->size <= (unsigned) INT_MAX);
  return solver->size;
}

/*------------------------------------------------------------------------*/

// The IPASIR interface returns '-elit' if 'elit' is assigned 'false' and
// 'elit' if it is assigned to 'true'.  Otherwise it returns zero.  We do
// not want to use 'import_literal' here, since this forces to adapt the
// size (and capacity) of the solver to this literal even though it did not
// occur in a clause yet.  So we have to do that importing manually.

int
satch_val (struct satch *solver, int elit)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE_NON_ZERO_VALID_LITERAL (elit);
  int eidx = abs (elit);
  assert (eidx > 0);
  assert (eidx != INT_MIN);
  const unsigned iidx = eidx - 1;
  if (iidx >= solver->size)
    return 0;
  const unsigned ilit = LITERAL (iidx);
  signed char tmp = solver->values[ilit];
  if (!tmp)
    return 0;
  int res = (tmp > 0) ? elit : -elit;
  if (elit < 0)
    res = -res;
  assert (res == elit || res == -elit);
  return res;
}

int
satch_solve (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  REQUIRE (EMPTY (solver->clause),
	   "incomplete clause (zero literal missing)");
  REQUIRE (!solver->status, "no incremental solving yet");
  if (solver->options.verbose)
    section (solver, "solving");
  int res = solve (solver);
  LOG ("internal solving procedure returns '%d'", res);
#ifndef NDEBUG
  if (res == 10)
    check_witness (solver);
#endif
  solver->status = res;
  return res;
}

/*------------------------------------------------------------------------*/

void
satch_set_verbose_level (struct satch *solver, int new_verbose_level)
{
  REQUIRE_NON_ZERO_SOLVER ();
  if (new_verbose_level < 0)
    new_verbose_level = 0;
#ifndef NDEBUG
  if (!solver->options.verbose && new_verbose_level > 1)
    checker_verbose (solver->checker);
#endif
  solver->options.verbose = new_verbose_level;
}

void
satch_enable_logging_messages (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
#ifndef NDEBUG
  solver->options.logging = true;
#else
  (void) solver;
#endif
  solver->options.verbose = INT_MAX;
}

/*------------------------------------------------------------------------*/

double
satch_process_time (void)
{
  return process_time ();
}

void
satch_start_profiling_parsing (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  START (parse);
}

double
satch_stop_profiling_parsing (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  return STOP (parse);
}

void
satch_section (struct satch *solver, const char *name)
{
  REQUIRE_NON_ZERO_SOLVER ();
  section (solver, name);
}

void
satch_statistics (struct satch *solver)
{
  REQUIRE_NON_ZERO_SOLVER ();
  const double stop = print_profiles (solver);
  print_statistics (solver, stop);
  print_resource_usage (solver, stop);
}
